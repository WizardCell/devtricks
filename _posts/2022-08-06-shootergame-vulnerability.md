---
layout: single
title: "The ShooterGame vulnerability that was spread to many games"
excerpt: In this post you'll learn about the major vulnerability of ShooterGame that got spread to many games.
header:
  teaser: /assets/images/per-post/shootergame-vulnerability/thumb.jpg
author: Meta
category: Videogames Development
tags:
  - Multiplayer
  - Security
  - UE5
  - UE4
  - ShooterGame
---

# Introduction

As most of you know, [ShooterGame](https://docs.unrealengine.com/4.27/en-US/Resources/SampleGames/ShooterGame/) is one of the most popular official Unreal Engine sample projects employed as a base in many well-known games: PUBG, Lawbreakers, ARK Survival Evolved, Hell Let Loose, Valorant...

Using a consolidated sample project as a base can shorten months of development, as many of the features included in the sample are needed as part of the vertical slice of many of these projects, so it makes sense for companies to explore the solutions offered by the engine developers, in this case Epic. Because who is going to be better at developing a game made in Unreal Engine than Epic itself?

I don't doubt that, but we, developers, are human, and we are by no means perfect machines capable to detect every single use case which would make a sample solid enough to be production ready. So oopsies can definitely happen.

In this post we'll learn about the major vulnerability of ShooterGame that spread across many projects using it as a base.

# Server side validation

ShooterGame provides a function to confirm whether a linetrace shoot is valid or not. This has to be done as the linetrace shooting in ShooterGame is performed purely in the client (for a 0 lag shooting experience), and then validated in the server in order to proceed with the damage calculation.

This technique is employed in many games and follows the principle of "trust and verify", in which we trust the client about the incoming shooting data, which then we validate.

Following next, we display ShooterGame's server side shooting validation:

{% highlight c++ %}
void AShooterWeapon_Instant::ServerNotifyHit_Implementation(const FHitResult& Impact, FVector_NetQuantizeNormal ShootDir, int32 RandomSeed, float ReticleSpread)
{
	const float WeaponAngleDot = FMath::Abs(FMath::Sin(ReticleSpread * PI / 180.f));

	// if we have an instigator, calculate dot between the view and the shot
	if (GetInstigator() && (Impact.GetActor() || Impact.bBlockingHit))
	{
		const FVector Origin = GetMuzzleLocation();
		const FVector ViewDir = (Impact.Location - Origin).GetSafeNormal();

		// is the angle between the hit and the view within allowed limits (limit + weapon max angle)
		const float ViewDotHitDir = FVector::DotProduct(GetInstigator()->GetViewRotation().Vector(), ViewDir);
		if (ViewDotHitDir > InstantConfig.AllowedViewDotHitDir - WeaponAngleDot)
		{
			if (CurrentState != EWeaponState::Idle)
			{
				if (Impact.GetActor() == NULL)
				{
					if (Impact.bBlockingHit)
					{
						ProcessInstantHit_Confirmed(Impact, Origin, ShootDir, RandomSeed, ReticleSpread);
					}
				}
				// assume it told the truth about static things because the don't move and the hit 
				// usually doesn't have significant gameplay implications
				else if (Impact.GetActor()->IsRootComponentStatic() || Impact.GetActor()->IsRootComponentStationary())
				{
					ProcessInstantHit_Confirmed(Impact, Origin, ShootDir, RandomSeed, ReticleSpread);
				}
				else
				{
					// Get the component bounding box
					const FBox HitBox = Impact.GetActor()->GetComponentsBoundingBox();

					// calculate the box extent, and increase by a leeway
					FVector BoxExtent = 0.5 * (HitBox.Max - HitBox.Min);
					BoxExtent *= InstantConfig.ClientSideHitLeeway;

					// avoid precision errors with really thin objects
					BoxExtent.X = FMath::Max(20.0f, BoxExtent.X);
					BoxExtent.Y = FMath::Max(20.0f, BoxExtent.Y);
					BoxExtent.Z = FMath::Max(20.0f, BoxExtent.Z);

					// Get the box center
					const FVector BoxCenter = (HitBox.Min + HitBox.Max) * 0.5;

					// if we are within client tolerance
					if (FMath::Abs(Impact.Location.Z - BoxCenter.Z) < BoxExtent.Z &&
						FMath::Abs(Impact.Location.X - BoxCenter.X) < BoxExtent.X &&
						FMath::Abs(Impact.Location.Y - BoxCenter.Y) < BoxExtent.Y)
					{
						ProcessInstantHit_Confirmed(Impact, Origin, ShootDir, RandomSeed, ReticleSpread);
					}
					else
					{
						UE_LOG(LogShooterWeapon, Log, TEXT("%s Rejected client side hit of %s (outside bounding box tolerance)"), *GetNameSafe(this), *GetNameSafe(Impact.GetActor()));
					}
				}
			}
		}
		else if (ViewDotHitDir <= InstantConfig.AllowedViewDotHitDir)
		{
			UE_LOG(LogShooterWeapon, Log, TEXT("%s Rejected client side hit of %s (facing too far from the hit direction)"), *GetNameSafe(this), *GetNameSafe(Impact.GetActor()));
		}
		else
		{
			UE_LOG(LogShooterWeapon, Log, TEXT("%s Rejected client side hit of %s"), *GetNameSafe(this), *GetNameSafe(Impact.GetActor()));
		}
	}
}
{% endhighlight %}

As we can see, this function validates the shooting angle alongside a simple bounding box calculation, which is great, as we are preventing shooting in non-allowed directions within a thresholded tolerance.

## The problem

With the function above, we are mitigating a number of cases in which a cheater could take advantage of our game, but we are forgetting something super important: All the calculations are done in relative space, we are never considering the world position of the pawn we are validating against.

So... we can do stuff like this:

![Teleport hack]({{ '/' | absolute_url }}/assets/images/per-post/shootergame-vulnerability/teleporthack.gif){: .align-center}

Yep, we just teleported a random player in front of us on our local client and killed them. This is because the validation heuristic doesn't account for the pawn world location.

So any malicious user could take this and use it to their advantage, which is exactly what happened in Hell Let Loose at its release (now fixed):

<iframe width="480" height="270" src="https://www.youtube.com/watch?v=2degQm1dZP0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

## How does it work?

Essentially, we can teleport players in our local client by doing memory manipulation (ie: [Cheat Engine](https://en.wikipedia.org/wiki/Cheat_Engine)). The server position of the pawns will remain unaffected however, we'll get to see enemy pawns in the desired position since we are manipulating their location on our computer.

For the shake of the example I created this little blueprint that emulates said functionality:

![Teleport hack logic]({{ '/' | absolute_url }}/assets/images/per-post/shootergame-vulnerability/hacklogic.jpg){: .align-center}

Fortunately, modern anti cheat systems (ie: [EAC](https://www.easy.ac/en-us/)) prevent software memory manipulation, but it's been demonstrated over the years that escaping anti cheat systems is possible. That's why our server-side validation code should be also robust.

## The solution

After showing the problem, I thought of a way to solve it in the shortest possible time. Since security vulnerabilities should be mitigated as quickly as possible while thinking of a more elaborate solution that would tremendously improve the problem.

In this case my fast solution involved a simple world location check embedded into the validation code:

{% highlight c++ %}
...
	// assume it told the truth about static things because the don't move and the hit 
	// usually doesn't have significant gameplay implications
	else if (Impact.GetActor()->IsRootComponentStatic() || Impact.GetActor()->IsRootComponentStationary())
	{
		ProcessInstantHit_Confirmed(Impact, Origin, ShootDir, RandomSeed, ReticleSpread);
	}
	else
	{
		// This is server side, so we can ensure that the impact location and the actor location are equivalent
		if (!Impact.Location.Equals(Impact.GetActor()->GetActorLocation(), 500.f))
		{
			UE_LOG(LogShooterWeapon, Log, TEXT("%s Rejected client side hit of %s (Impact Location doesn't match actor location)"), *GetNameSafe(this), *GetNameSafe(Impact.GetActor()));
			return;
		}

		// Get the component bounding box
		const FBox HitBox = Impact.GetActor()->GetComponentsBoundingBox();
...
{% endhighlight %}

As we can see, our simple and not involved solution is checking if the impact location is equal to the actor location server sided with some tolerance accounted for. This is because, intuitively the actor location should be close to the impact location. I've added a big tolerance as lag is a big factor on online games. With this fix, when we try to kill teleported pawns, we will fail as the server will reject the shoot:

![Teleport hack hotfixed]({{ '/' | absolute_url }}/assets/images/per-post/shootergame-vulnerability/teleporthacksolved.gif){: .align-center}

This isn't the best solution for the problem but it's good enough to mitigate partially the teleport issue while we buy some time to build a proper and more involved solution (rewinding the victim's capsule and checking against it).

# Conclusion

I hope this little anecdote will make you think about the implications and importance of security in online games for an enjoyable gameplay experience for everyone.

In addition, in game development it is important to know how to mitigate problems temporarily until a more robust solution is found, especially if we are in production. Obviously all this under a controlled environment while providing functional code (test you stuff!!).

Finally I'd like to encourage you to [support me on twitter with a follow](https://twitter.com/vorixo) so more people can get to read my little tales about net programming and game development in general!

Thanks for reading, vori.
